/*
*******************************************************************************
* Copyright (C) 2013,2016 International Business Machines Corporation. 
* All Rights Reserved. *
*******************************************************************************
*/
namespace com.ibm.streamsx.plumbing.sample.redundant.flow ;

/**
 * Type used in [Flow].
*/
type T = uint64 id, float64 v;

/**
 * Simple flow to be executed multiple times
 * to provide redundant copies.
 * The actual functionality of the flow
 * is basically nothing, it is just to demonstrate
 * the execution of redundant copies.
 *
 * The premise is an application that reads from
 * some data source (say a message broker), analyzes the
 * streams and then sends SMS alerts based upon the analysis.
 */
public composite Flow
{
    graph
    stream<T> Messages = Analytics() {}
    () as SMS = SendSMS(Messages) {}
}

/**
 * The "analytics" portion of the application
 * including the source.
*/
public composite Analytics(output Messages)
{
    graph
        stream<T> Source = Beacon()
        {
          param
            period: 0.05;
          output Source:
               id = IterationCount(),
               v = random();
        }

        stream<T> FA1 = Functor(Source) { }
        stream<T> FA2 = Filter(FA1) {
          param filter: v <= 0.10;
        }

        stream<T> FB1 = Functor(Source) { }
        stream<T> FB2 = Functor(FB1) {
          param filter: v >= 0.80;
        }

        stream<T> Messages = Functor(FA2,FB2) { }
}

/**
 * The sink of the application.
 * This does nothing but consume the tuples.
 * It it representing a hypothetical operator
 * that sends a SMS (text message) alert for
 * each tuple received.
*/
public composite SendSMS(input Messages)
{
    graph
     () as SMS = Custom(Messages) { }
}
